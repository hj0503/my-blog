### diff 算法

- 比较只会在同层级进行, 不会跨层级比较
- 在 `diff` 比较的过程中，循环从两边向中间比较(双端比较)

#### 触发节点更新

当数据发生改变时，会调用`patch`进行打补丁，更新响应的试图

#### patch

- 没有新节点，直接触发旧节点的`destory`钩子删除该节点
- 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接创建新节点，所以只调用 `createElm`
- 旧节点和新节点自身一样，通过 `sameVnode` 判断节点是否一样，一样时，直接调用 `patchVnode`去处理这两个节点
- 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点

#### patchVnode

- 新节点是否是文本节点，如果是，则直接更新 `DOM` 的文本内容为新节点的文本内容
- 新节点和旧节点如果都有子节点，则处理比较更新子节点
- 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新 `DOM`，并且添加进父节点
- 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把 `DOM` 删除
- 新旧子节点都存在，并且子节点不完全一致，则调用 `updateChildren`，这个里面就是`diff`算法的核心

#### updateChildren

- 当新老 `VNode` 节点的 `start` 相同时，直接 `patchVnode` ，同时新老 `VNode` 节点的开始索引都加 1
- 当新老 `VNode` 节点的 `end` 相同时，同样直接 `patchVnode` ，同时新老 `VNode` 节点的结束索引都减 1
- 当老 `VNode` 节点的 `start` 和新 `VNode` 节点的 `end` 相同时，这时候在 `patchVnode` 后，还需要将当前真实 `dom` 节点移动到 - `oldEndVnode` 的后面，同时老 `VNode` 节点开始索引加 1，新 `VNode` 节点的结束索引减 1
- 当老 `VNode` 节点的 `end` 和新 `VNode` 节点的 start 相同时，这时候在 `patchVnode` 后，还需要将当前真实 `dom` 节点移动到 - `oldStartVnode` 的前面，同时老 `VNode` 节点结束索引减 1，新 `VNode` 节点的开始索引加 1
- 如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：
- 从旧的 `VNode` 为 `key` 值，对应 `index` 序列为 `value` 值的哈希表中找到与 `newStartVnode` 一致 `key` 的旧的 VNode 节点，再进- 行 `patchVnode，同时` 将这个真实 `dom` 移动到 `oldStartVnode` 对应的真实 `dom` 的前面
- 调用 `createElm` 创建一个新的 `dom` 节点放到当前 `newStartIdx` 的位置
