# Vue 3 响应式原理（深入但好懂）

- 目标：理解 Vue 3 响应式系统如何工作，并能用简化版代码实现核心机制。
- 核心关键词：Proxy、effect、track/trigger、targetMap、dep、scheduler、computed、watch。

## 为什么是 Proxy（对比 Vue 2）

- Vue 2 基于 `Object.defineProperty` 拦截 `get/set`，难以良好支持 `Map/Set`、数组索引、新增属性。
- Vue 3 使用 `Proxy` 拦截器：
  - 能覆盖更多操作：`get/set/deleteProperty/has/ownKeys`，迭代、键集合等。
  - 原生支持 `Map/Set/WeakMap/WeakSet` 等集合类型。
  - 性能更好、设计更清晰。

## 核心概念与流程

- `effect(fn)`：注册一个副作用函数。当响应式数据变更时，重新执行 `fn`。
- 依赖收集（track）：在 `effect` 执行期间，读取响应式数据的 `get` 会记录依赖关系。
- 触发更新（trigger）：当对响应式数据执行 `set/delete/clear` 等变更操作时，找到依赖并调度重新执行。
- 依赖容器：
  - `targetMap: WeakMap<object, Map<key, Dep>>`
  - `Dep: Set<ReactiveEffect>`（副作用集合）
- 调度器（scheduler）：
  - 控制副作用执行时机，避免重复执行或控制刷新时间。
  - 例如 `computed` 用调度器实现“惰性求值”和“脏值标记”。

流程简图（文字版）：
- 读取：`proxy.get(key)` → `track(target, key)` 记录当前活动的 `effect`。
- 变更：`proxy.set(key, value)` → `trigger(target, key, type)` 查找依赖的 `effect` 并调度执行。
- 迭代：`ownKeys`（如 `for...in`）或集合迭代 → 使用特殊的 `ITERATE_KEY` 进行依赖绑定。

## 常用 API 心智模型

- `reactive(obj)`：为对象创建深层响应式代理。
- `ref(value)`：为基本类型或对象创建含 `.value` 的响应式容器。
- `computed(getter | { get, set })`：基于依赖“惰性计算”，带缓存。
- `watch(source, cb, options)`：侦听响应式源的变更（深度/即时/刷新时机）。
- `watchEffect(fn, options)`：立即执行并自动依赖收集的副作用。
- `readonly(obj)`：只读代理，开发环境下写入报警。
- `shallowReactive/shallowRef`：仅第一层响应式，不递归。
- `toRef/toRefs`：在 `reactive` 上创建 ref 引用，避免解构失去响应式。
- `markRaw/toRaw`：标记或提取原始对象以跳过/解除响应式。

## 简化实现（教学版代码）

以下是一个“最小可用”的简化实现，帮助你把握关键机制。注意：仅教学用途，未覆盖所有边界与优化。

```js
// 极简版响应式核心（教学用）
// 目标：展示 effect / track / trigger / reactive / computed / watch 的基本关系

const targetMap = new WeakMap(); // WeakMap<object, Map<key, Dep>>
let activeEffect = null;
const effectStack = [];

// 注册副作用
function effect(fn, options = {}) {
  const runner = function reactiveEffect() {
    try {
      activeEffect = runner;
      effectStack.push(runner);
      return fn();
    } finally {
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1] || null;
    }
  };
  runner.scheduler = options.scheduler;
  runner.deps = [];
  runner.active = true;

  if (!options.lazy) {
    runner();
  }
  return runner;
}

// 依赖收集
function track(target, key) {
  if (!activeEffect || !activeEffect.active) return;
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    depsMap = new Map();
    targetMap.set(target, depsMap);
  }
  let dep = depsMap.get(key);
  if (!dep) {
    dep = new Set();
    depsMap.set(key, dep);
  }
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}

// 触发更新
function trigger(target, key, type) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  const effects = new Set();
  const dep = depsMap.get(key);
  if (dep) dep.forEach(e => effects.add(e));

  // 迭代相关（如 for...in）可使用特殊 ITERATE_KEY，这里略
  // if (type === 'add' || type === 'delete') {
  //   const iterateDep = depsMap.get(ITERATE_KEY);
  //   if (iterateDep) iterateDep.forEach(e => effects.add(e));
  // }

  effects.forEach(effectFn => {
    if (effectFn.scheduler) {
      effectFn.scheduler(effectFn);
    } else {
      effectFn();
    }
  });
}

// reactive（对象代理）
function reactive(target) {
  if (typeof target !== 'object' || target === null) return target;
  return new Proxy(target, {
    get(t, key, receiver) {
      const res = Reflect.get(t, key, receiver);
      track(t, key);
      return typeof res === 'object' && res !== null ? reactive(res) : res;
    },
    set(t, key, value, receiver) {
      const oldVal = t[key];
      const hadKey = Object.prototype.hasOwnProperty.call(t, key);
      const result = Reflect.set(t, key, value, receiver);
      if (!hadKey) {
        trigger(t, key, 'add');
      } else if (oldVal !== value) {
        trigger(t, key, 'set');
      }
      return result;
    },
    deleteProperty(t, key) {
      const hadKey = Object.prototype.hasOwnProperty.call(t, key);
      const result = Reflect.deleteProperty(t, key);
      if (hadKey && result) {
        trigger(t, key, 'delete');
      }
      return result;
    },
    ownKeys(t) {
      // for...in / Object.keys 依赖点，通常绑定到 ITERATE_KEY
      // 省略：track(t, ITERATE_KEY)
      return Reflect.ownKeys(t);
    },
    has(t, key) {
      // in 操作符也会触发 track
      track(t, key);
      return Reflect.has(t, key);
    }
  });
}

// ref（简化版）
function ref(value) {
  const r = {
    get value() {
      track(r, 'value');
      return value;
    },
    set value(v) {
      if (v !== value) {
        value = v;
        trigger(r, 'value', 'set');
      }
    }
  };
  return r;
}

// computed（带缓存、脏值标记）
function computed(getter) {
  let cached;
  let dirty = true;

  const runner = effect(getter, {
    lazy: true,
    scheduler: () => {
      dirty = true;
      trigger(obj, 'value', 'set'); // 通知依赖该 computed 的副作用
    }
  });

  const obj = {
    get value() {
      if (dirty) {
        cached = runner();
        dirty = false;
      }
      track(obj, 'value');
      return cached;
    }
  };
  return obj;
}

// watch（简化版）
function traverse(value, seen = new Set()) {
  if (typeof value !== 'object' || value === null || seen.has(value)) return;
  seen.add(value);
  for (const key in value) {
    traverse(value[key], seen);
  }
  return value;
}

function watch(source, cb, options = {}) {
  let getter;
  if (typeof source === 'function') {
    getter = source;
  } else {
    getter = () => traverse(source);
  }

  let oldVal, cleanup;
  function onCleanup(fn) {
    cleanup = fn;
  }

  const job = () => {
    if (cleanup) cleanup();
    const newVal = runner();
    cb(newVal, oldVal, onCleanup);
    oldVal = newVal;
  };

  const runner = effect(getter, {
    lazy: true,
    scheduler: options.flush === 'sync' ? job
      : () => Promise.resolve().then(job) // 简化版：默认微任务 post
  });

  oldVal = runner();
  if (options.immediate) job();
}
```

示例使用：

```js
const state = reactive({ count: 0, nested: { m: 1 } });

effect(() => {
  console.log('count changed:', state.count);
});

state.count++; // 触发 effect

const doubled = computed(() => state.count * 2);
effect(() => console.log('doubled:', doubled.value)); // 缓存 + 依赖收集

watch(
  () => state.nested.m,
  (n, o) => console.log('nested.m changed:', o, '->', n),
  { immediate: true }
);

state.nested.m = 2;
```

## 集合类型（Map/Set）与迭代

- Vue 3 对 `Map/Set` 做了“仪表化”（instrumentation），让 `get/set/has/delete/forEach/keys/values/entries` 都能参与依赖收集与触发。
- 迭代相关依赖：
  - `for...in`、`Object.keys`、`Reflect.ownKeys` 等使用 `ITERATE_KEY`。
  - `Map` 的键迭代使用 `MAP_KEY_ITERATE_KEY`。
- 当执行 `add/delete/clear` 时，需要触发对应迭代依赖（因为集合大小和键集合发生变化）。

## Ref 的解包行为

- 在模板中，`ref` 会自动解包（不需要 `.value`）。
- 在响应式对象上访问属性时，Vue 3 对嵌套的 `ref` 存在解包规则（在普通对象属性访问中会解包，但数组索引等场景不解包），以避免破坏数组语义。
- 在脚本中建议显式使用 `.value`，避免语义混淆。

## watch 刷新时机

- `flush: 'pre'`：在组件渲染前（默认）。
- `flush: 'post'`：在组件渲染后（微任务）。
- `flush: 'sync'`：同步执行（谨慎使用）。
- `watchEffect` 与 `watch` 的调度类似，但 `watchEffect` 无需显式指定依赖源，初次执行时自动收集。

## 停止与清理

- `effect` 返回的 `runner` 可被“停止”（框架内置有更完整的 `stop` API 和 `EffectScope`），教学版可通过标记 `runner.active = false` 实现。
- `watch` 的清理函数通过第三个参数 `onCleanup` 提供，以避免竞态或资源泄漏（例如清理定时器、取消请求）。

## 常见坑与最佳实践

- 避免对 `reactive` 对象“解构”后直接使用，建议用 `toRefs` 保持响应式。
- 基本类型用 `ref`，对象/数组用 `reactive`。
- `computed` 只用于纯派生数据，避免其中产生副作用。
- `readonly` 是只读代理，内部原始对象仍可变；写入会在开发态报警。
- 给第三方库实例使用 `markRaw`，避免无意义的代理开销。
- 深度监听对象用 `watch(obj, ...)` 并注意性能（可结合 `deep` 和精准 `getter`）。
- 在 `watch` 的 `source` 中尽量提供精准的 getter，而不是整个对象的深度遍历。

## 与 Vue 2 的差异总结

- 基于 `Proxy`，天然支持 `Map/Set` 等集合类型。
- 依赖收集更精细（迭代、键集合、大小变化都可追踪）。
- 计算属性基于调度器实现“惰性 + 缓存”，减少无意义计算。
- watch 刷新时机更灵活，可与渲染队列更好协作。

## 结语

- 掌握“读取时 track，写入时 trigger”的核心心智模型，就能理解 Vue 3 响应式的绝大部分行为。
- 教学版代码覆盖了关键路径，真实实现还包含：边界优化、集合仪表化、Ref 解包细则、错误处理、开发提示等，建议在源码或官方文档的基础上进一步深入。
