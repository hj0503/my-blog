### 响应式原理

#### 1.响应式对象 observe

##### 简介

将`data`中的值转换成响应式数据

步骤：initState -> initData -> observe -> new Observer -> 数组：observeArray，对象：walk -> 对象：遍历对象调用 defineReactive -> 递归调用 observe（对象里面有对象的值时）,通过 Object.defineProperty 将 data 中值的所有属性设置成响应式数据

##### 逐步分析

1. 首先在初始化的时候会调用`initState`方法，也就是初始化`props`、`methods`、`data`、`computed`、`watch`中的数据。
2. 对于 data 来说，会调用`initData`方法，在里面调用`observe`，在`observe`中调用`Observer`构造函数(class)
3. `Observer`会判断传入的 data 是数组还是对象，数组调用`Observer`中的`observeArray`方法，对象调用`Observer`中的`walk`方法，通常我们的写法都是对象
4. `walk`中遍历对象调用`defineReactive`方法，传入 data 以及 key
5. `defineReactive`使用`Object.defineProperty`把数据转换成响应式数据(设置 set、get)，这个时候如果对象某个属性的值也为对象时递归调用`observe`方法将对象的中的所有层级属性值都设置成响应式数据

#### 2.依赖收集

##### 简介

将依赖收集起来，Dep 为存放依赖(Watcher)的地方，Watcher 为依赖也就是观察者，里面有 getter 也就是 updateComponent 进行更新组件

##### 逐步分析

1. 初始化 component(mountComponent)时调用 new Watcher

```javascript
updateComponent = () => {
  vm._update(vm._render(), hydrating); // 渲染component
};

new Watcher(
  vm,
  updateComponent,
  noop,
  {
    before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    },
  },
  true /* isRenderWatcher */
);
```

2. 在 Watcher 的 constructor 中会调用 get 方法，然后调用 pushTarget 进行依赖收集，并且在 get 方法中执行 updateComponent

```javascript
this.value = this.lazy ? undefined : this.get();

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}
```

3. 然后在所有的组件渲染完后会进入到 Object.defineProperty 的 get 中进行依赖再收集(属性值为对象时)

```javascript
get: function reactiveGetter () {
  var value = getter ? getter.call(obj) : val;
  if (Dep.target) { // 当前的Watcher
    dep.depend();
    if (childOb) {
      childOb.dep.depend();
      if (Array.isArray(value)) {
        dependArray(value);
      }
    }
  }
  return value
},
```
